[gd_resource type="Shader" format=2]

[resource]
code = "shader_type spatial;
render_mode specular_schlick_ggx;

uniform float Fps;
uniform int Frames;
uniform int Animations;
uniform int UsedAnimations;
uniform sampler2D Texture : hint_albedo;
uniform sampler2D Background : hint_albedo;
uniform int tex_width;
uniform int tex_height;
uniform int margin;



void vertex() {
// Output:0

}

void fragment() {
	float mar_x = float(margin) / float(tex_width);
	float mar_y = float(margin) / float(tex_height);
	
	float mar_x_bg = mar_x * float(Animations);
	float mar_y_bg = mar_y * float(Frames) / float(Animations);
	
	int frame = int(TIME * Fps) mod Frames;
	int animation = 0; 
	
	if(COLOR.r > 0.0) {
		animation = min(int(COLOR.r * float(UsedAnimations - 1)) + 1, UsedAnimations - 1);
	}
	
	float dx = 1.0 / float(Animations);
	float dy = 1.0 / float(Frames);
	float tile_width = dx - 2.0 * mar_x;
	float tile_height = dy - 2.0 * mar_y;
	
	vec2 uv_scaled = vec2(
		mar_x + tile_width * UV.x + float(animation) * dx,
		mar_y + tile_height * UV.y + float(frame) * dy
	);
	
	float dy_bg = 1.0 / float(Animations);
	float tile_width_bg = 1.0 - 2.0 * mar_x_bg;
	float tile_height_bg = dy_bg - 2.0 * mar_y_bg;
	vec2 uv_scaled_bg = vec2(
		mar_x_bg + tile_width_bg * UV.x,
		mar_y_bg + tile_height_bg * UV.y + float(animation) * dy_bg
	);
	
	vec4 tex_read = texture(Texture, uv_scaled);
	vec4 bg_read = texture(Background, uv_scaled_bg);
	
	ALBEDO = bg_read.rgb * (1.0 - tex_read.a) + (tex_read.rgb * tex_read.a);
}

void light() {
// Output:0

}
"
